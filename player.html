<!DOCTYPE html><html>
<head>
  <meta charset="utf-8">
  <title>Tilemap with Player</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
      background: #000;
    }
    #joystick-container {
      position: absolute;
      left: 30px;
      bottom: 30px;
      width: 100px;
      height: 100px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50%;
      touch-action: none;
    }
    #joystick {
      position: absolute;
      left: 25px;
      top: 25px;
      width: 50px;
      height: 50px;
      background: rgba(255, 255, 255, 0.4);
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="joystick-container">
    <div id="joystick"></div>
  </div>  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const TILE_SIZE = 64;
    const tilemap = {
      layers: [],
      tilewidth: 64,
      tileheight: 64,
      tilesetColumns: 15
    };

    const tileImage = new Image();
    const playerImage = new Image();
    tileImage.src = "tile64_new.png";
    playerImage.src = "player.png";

    const player = {
      x: 0,
      y: 0,
      width: 32,
      height: 32,
      speed: 4
    };

    const camera = { x: 0, y: 0 };

    const keys = {};
    const joystick = { dx: 0, dy: 0 };

    window.addEventListener("keydown", e => keys[e.key] = true);
    window.addEventListener("keyup", e => keys[e.key] = false);

    async function loadTilemap() {
      const res = await fetch("tilemap.json");
      const data = await res.json();

      tilemap.tilewidth = data.tilewidth;
      tilemap.tileheight = data.tileheight;
      tilemap.tilesetColumns = data.tilesets[0].columns;
      tilemap.firstgid = data.tilesets[0].firstgid;
      tilemap.margin = data.tilesets[0].margin || 0;
      tilemap.spacing = data.tilesets[0].spacing || 0;
      tilemap.mapWidth = data.width;
      tilemap.mapHeight = data.height;
      tilemap.layers = data.layers.filter(l => l.type === 'tilelayer');

      player.x = data.width * data.tilewidth / 2;
      player.y = data.height * data.tileheight / 2;
    }

    function getTileAt(x, y) {
      const tx = Math.floor(x / TILE_SIZE);
      const ty = Math.floor(y / TILE_SIZE);
      if (tx < 0 || tx >= tilemap.mapWidth || ty < 0 || ty >= tilemap.mapHeight) return 0;
      const index = ty * tilemap.mapWidth + tx;
      const solidLayer = tilemap.layers.find(l => l.name === "tile");
      if (!solidLayer) return 0;
      return solidLayer.data[index];
    }

    function isRectColliding(x, y, width, height) {
      const corners = [
        [x, y],
        [x + width - 1, y],
        [x, y + height - 1],
        [x + width - 1, y + height - 1]
      ];
      return corners.some(([cx, cy]) => getTileAt(cx, cy) !== 0);
    }

    function drawLayer(layer) {
      const data = layer.data;
      for (let y = 0; y < tilemap.mapHeight; y++) {
        for (let x = 0; x < tilemap.mapWidth; x++) {
          const index = y * tilemap.mapWidth + x;
          const gid = data[index];
          const dx = x * TILE_SIZE - camera.x + canvas.width / 2 - player.x;
          const dy = y * TILE_SIZE - camera.y + canvas.height / 2 - player.y;
          if (gid > 0) {
            const tileIndex = gid - tilemap.firstgid;
            const sx = tilemap.margin + (tileIndex % tilemap.tilesetColumns) * (TILE_SIZE + tilemap.spacing);
            const sy = tilemap.margin + Math.floor(tileIndex / tilemap.tilesetColumns) * (TILE_SIZE + tilemap.spacing);
            ctx.drawImage(tileImage, Math.floor(sx), Math.floor(sy), TILE_SIZE, TILE_SIZE, Math.floor(dx), Math.floor(dy), TILE_SIZE, TILE_SIZE);
          }

          // draw collision outline (debug)
          const solidLayer = tilemap.layers.find(l => l.name === "tile");
          if (solidLayer && solidLayer.data[index] !== 0) {
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.strokeRect(Math.floor(dx), Math.floor(dy), TILE_SIZE, TILE_SIZE);
          }
        }
      }
    }

    function updatePlayer() {
      const dx = ((keys['ArrowRight'] || joystick.dx > 0.2 ? 1 : 0) - (keys['ArrowLeft'] || joystick.dx < -0.2 ? 1 : 0)) * player.speed;
      const dy = ((keys['ArrowDown'] || joystick.dy > 0.2 ? 1 : 0) - (keys['ArrowUp'] || joystick.dy < -0.2 ? 1 : 0)) * player.speed;

      const nextX = player.x + dx;
      const nextY = player.y + dy;

      if (!isRectColliding(nextX, player.y, player.width, player.height)) {
        player.x = nextX;
      }
      if (!isRectColliding(player.x, nextY, player.width, player.height)) {
        player.y = nextY;
      }

      camera.x = player.x;
      camera.y = player.y;
    }

    function drawPlayer() {
      ctx.drawImage(playerImage, canvas.width / 2 - 16, canvas.height / 2 - 16, 32, 32);
      // draw player collision box (debug)
      ctx.strokeStyle = 'lime';
      ctx.strokeRect(canvas.width / 2 - 16, canvas.height / 2 - 16, 32, 32);
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      tilemap.layers.forEach(drawLayer);
      updatePlayer();
      drawPlayer();
      requestAnimationFrame(gameLoop);
    }

    tileImage.onload = async () => {
      await loadTilemap();
      gameLoop();
    };

    const joystickContainer = document.getElementById("joystick-container");
    const joystickStick = document.getElementById("joystick");
    let isDragging = false;

    joystickContainer.addEventListener("touchstart", () => isDragging = true);
    joystickContainer.addEventListener("touchmove", (e) => {
      if (!isDragging) return;
      const touch = e.touches[0];
      const rect = joystickContainer.getBoundingClientRect();
      const x = touch.clientX - rect.left - 50;
      const y = touch.clientY - rect.top - 50;

      const dx = Math.max(-50, Math.min(50, x));
      const dy = Math.max(-50, Math.min(50, y));

      joystickStick.style.left = `${dx + 50 - 25}px`;
      joystickStick.style.top = `${dy + 50 - 25}px`;

      joystick.dx = dx / 50;
      joystick.dy = dy / 50;
    });

    joystickContainer.addEventListener("touchend", () => {
      isDragging = false;
      joystickStick.style.left = "25px";
      joystickStick.style.top = "25px";
      joystick.dx = 0;
      joystick.dy = 0;
    });
  </script></body>
</html>
